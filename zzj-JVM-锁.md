## 线程和锁

#### 线程安全

对于线程共享对象的访问，需要加锁，不然会出现对象值不对

#### 对象头Mark

- 对象头的标记，32位

- 描述对象的hash、锁信息，垃圾回收标记，年龄

  - 指向锁记录的指针
  - 指向 monitor 的指针
  - GC 标记
  - 偏向锁线程ID




## JVM层面锁获取方式

#### 偏向锁

- 大部分情况是没有竞争的，所以可以通过偏向来提高性能

- 所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程

- 将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark

- 只要没有竞争，获得偏向锁的线程，在将来进入同步块，不需要做同步

- 当其他线程请求相同的锁时，偏向模式结束

- -XX:+UseBiasedLocking

- 默认启用

- 在竞争激烈的场合，偏向锁会增加系统负担



#### 轻量级锁

- BasicObjectLock
  - 嵌入在线程栈中的对象
- 

#### 自旋锁



## java语言层面-锁优化

#### 减少锁持有时间

锁作用范围：方法，字段，代码块



#### 减少锁粒度

将需要同步的大对象分离成小对象的过程

#### 锁分离

根据功能进行锁分离

ReadWriteLock

读多写少的情况可以提高性能



#### 锁粗化

通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。



#### 锁消除

jvm会自动消除没有必要加锁的地方的锁，需要设置一些参数才可以。



#### 无锁

CAS（比较交换）

atomic 包中的类使用的同步方式基本都是 无锁方式，无锁方式是效率比较高的方式。



