- [一、java内存组成：堆和非堆](#一java内存组成堆和非堆)
    - [1.堆和栈区别](#1堆和栈区别)     
    - [2.深入理解栈](#2深入理解栈)   
    - [3.深入理解堆](#3深入理解堆)    
- [二、JVM内存区域模型](#二-JVM-内存区域模型)
    - [1.方法区](#1方法区)
    - [2.程序计数器](#2程序计数器)    
- [三、java堆内存的10个要点](#三java堆内存的10个要点)

## 参考
[Java虚拟机的内存组成以及堆内存介绍](http://www.hollischuang.com/archives/80)       
[Java堆和栈看这篇就够](https://iamjohnnyzhuang.github.io/java/2016/07/12/Java%E5%A0%86%E5%92%8C%E6%A0%88%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F.html)     
[Java虚拟机的堆、栈、堆栈如何去理解？](https://www.zhihu.com/question/29833675)     
[Java 内存之方法区和运行时常量池](https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/)      
[从0到1起步-跟我进入堆外内存的奇妙世界](https://www.jianshu.com/p/50be08b54bee)     



## 一、java内存组成：堆和非堆
>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。      

### 1.堆和栈区别
- 功能不同      
    - 栈内存用来存储局部变量和方法调用      
    - 堆内存用来存储java中的对象，无论是成员变量，局部变量，还是类变量，它们都指向了堆内存。            
- 共享性不同        
    - 栈内存时线程私有的。      
    - 堆内存时所有线程共有的。          
- 异常错误不同      
    - 栈空间不足：java.lang.StackOverFlowError  
    - 堆空间不足：java.lang.OutOfMemoryError    
- 空间大小
    - 栈空间远小于堆

### 2.深入理解栈
#### 为什么函数调用栈来实现？
“调用栈”（call stack）既可以之具体实现，也可以指一种抽象概念--由“栈帧（stack frame）”或者“活动记录”构成的栈。   
函数调用的局部状态之所有用栈来记录是因为这些数据的存活时间满足“后入先出（LIFO）”顺序，而栈的基本操作就是这种顺序。  
例有：

```java
int main(){
    a();
    return 0;
}

void a(){
    b();
}
void b(){
    c();
}
void c(){
}
```
这个过程如下：

```
main()  a()  b()  c()
   -                         main()
   |
   +>     -                    a()
   .      |
   .      +>   -                 b()
   .      .    |
   .      .    +>   -              c()
   .      .    .    |
   .      .    +   <-              return from c()
   .      .    |
   .      +   <-                 return from b()
   .      |
   +     <-                    return from a()
   |
   -                         return from main()
```
可以看到，函数的调用有完美的嵌套关系——**调用者的生命期总是长于被调用者的生命期，并且后者在前者的之内。**        

这样，被调用者的局部信息所在空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出）。

#### 栈概念
JVM规范让每个java线程有用自己独立的JVM栈，也就是java方法的调用栈。  
同时JVM规范为了允许 native 代码可以调用java 代码，以及允许java代码调用native方法，还规定每个java线程拥有自己的独立的native方法栈。  

栈是由栈帧组成，每当线程调用一个java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由局部变量区、操作数栈和帧数据区组成。     

#### 栈帧组成
栈帧由三部分组成：局部变量区，操作数栈，帧数据区。      
- **局部变量区**    
局部变量区被组织为以一个字长为单位、从0开始计数的数组，类型为short、byte和char的值在存入数组前要被转换成int值，而long和double在数组中占据连续的两项，在访问局部变量中的long或double时，只需取出连续两项的第一项的索引值即可,如某个long值在局部变量区中占据的索引时3、4项，取值时，指令只需取索引为3的long值即可。

- **操作数栈**  
和局部变量区一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过入栈和出栈来访问的。可把操作数栈理解为存储计算时，临时数据的存储区域。下面我们通过一段简短的程序片段外加一幅图片来了解下操作数栈的作用。
```java
int a = 1;
int b = 98;
int c = a+b;	
```
![操作数栈](https://iamjohnnyzhuang.github.io/public/upload/4.png)
从图中可以得出：操作数栈其实就是个临时数据存储区域，它是通过入栈和出栈来进行操作的。

- **帧数据区**      
除了局部变量区和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。这些数据都保存在java栈帧的帧数据区中。

当JVM执行到需要常量池数据的指令时，它都会通过帧数据区中指向常量池的指针来访问它。

 除了处理常量池解析外，帧里的数据还要处理java方法的正常结束和异常终止。如果是通过return正常结束，则当前栈帧从Java栈中弹出，恢复发起调用的方法的栈。如果方法又返回值，JVM会把返回值压入到发起调用方法的操作数栈。

为了处理java方法中的异常情况，帧数据区还必须保存一个对此方法异常引用表的引用。当异常抛出时，JVM给catch块中的代码。如果没发现，方法立即终止，然后JVM用帧区数据的信息恢复发起调用的方法的帧。然后再发起调用方法的上下文重新抛出同样的异常。


### 3.深入理解堆
JVM里的堆（heap）特指用于存放java对象的内存区域，根据这个定义，java对象全都在堆上。要注意，这个“堆”并不是数据结构意义上的堆，而是动态内存分配意义上的堆——用于管理动态生命周期的内存区域。



## 二、JVM内存区域模型
![jvm内存模型](http://www.hollischuang.com/wp-content/uploads/2015/04/2354447461.jpg)

### 1.方法区
1.同java堆一样，方法区也是全局共享的一块内存区域。        
2.方法区的作用是存储java类的结构信息，当我们创建对象实例后，**对象的类型信息存储在方法区之中，实例数据放在堆中** 
- 实例数据 指的是在java中创建的各种实例对象及它们的值       
- 类型信息指的是定义在java代码中的常量、静态变量、以及在类中声明的各种方法、方法字段等

方法区中包含了运行时常量池。    
1.运行时常量池作用是存储java类文件常量池中的符号信息。      
2.class文件中存在常量池(非运行时常量池)，其在编译阶段就已经确定；JVM 规范对 class 文件结构有着严格的规范，必须符合此规范的 class 文件才会被 JVM 认可和装载。
3.运行时常量池 中保存着一些 class 文件中描述的符号引用，同时还会将这些符号引用所翻译出来的直接引用存储在 运行时常量池 中。      
4.运行时常量池相对于 class 常量池一大特征就是其具有动态性，Java 规范并不要求常量只能在运行时才产生，也就是说运行时常量池中的内容并不全部来自 class 常量池，class 常量池并非运行时常量池的唯一数据输入口；在运行时可以通过代码生成常量并将其放入运行时常量池中。     

### 2.程序计数器
是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

## 三、java堆内存的10个要点
1. Java堆内存是操作系统分配给JVM的内存的一部分。
2. 当我们创建对象时，它们存储在Java堆内存中。
3. 为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。
4. 你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。
5. 你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。
6. 你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。
7. Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。
8. Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。
9. 当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。
10. 请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。


