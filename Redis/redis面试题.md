## 常见的Redis面试题及分布式集群讲解
- 1、 **使用Redis有哪些好处？**

   -  1、速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 
   
   - 2、 支持丰富数据类型，支持string，list，set，sorted set，hash 
   - 3、支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 
   - 4、丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

- 2、 **redis相比memcached有哪些优势**

   - 1、memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 
   
   - 2、 redis的速度比memcached快很多 
   
   - 3、redis可以持久化其数据

- 3、**redis常见性能问题和解决方案：**

   - 1、Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件 

   - 2、如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 
   - 3、为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 
   - 4、尽量避免在压力很大的主库上增加从库 
   - 5、主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3… 
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。

- 4、**MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据**
   
   相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：

   - **voltile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

   - **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

   - **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

   - **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

   - **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰

   - **no-enviction**（驱逐）：禁止驱逐数据

- 5、**Memcache与Redis的区别都有哪些**
   - 1、存储方式

       - Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。

      - Redis有部份存在硬盘上，这样能保证数据的持久性。
  
  - 2、数据支持类型

      - Memcache对数据类型支持相对简单。

      - Redis有复杂的数据类型
 - 3、使用底层模型不同
      -  它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。

      - Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

  - 4、value大小
   
      - redis最大可以达到1GB，而memcache只有1MB

- 6、**Redis 常见的性能问题都有哪些？如何解决？**

   - 1、Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。

   - 2、Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。

   - 3、Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。

   - 4、Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内

- 7、**个人总结了以下多种Web应用场景，在这些场景下可以充分的利用Redis的特性，大大提高效率。**

   -   在主页中显示最新的项目列表：Redis使用的是常驻内存的缓存，速度非常快。LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。
   
   - 删除和过滤：如果一篇文章被删除，可以使用LREM从缓存中彻底清除掉。
   - 排行榜及相关问题：排行榜（leader board）按照得分进行排序。ZADD命令可以直接实现这个功能，而ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。
   - 按照用户投票和时间排序：排行榜，得分会随着时间变化。LPUSH和LTRIM命令结合运用，把文章添加到一个列表中。一项后台任务用来获取列表，并重新计算列表的排序，ZADD命令用来按照新的顺序填充生成列表。列表可以实现非常快速的检索，即使是负载很重的站点。
   - 过期项目处理：使用Unix时间作为关键字，用来保持列表能够按时间排序。对current_time和time_to_live进行检索，完成查找过期项目的艰巨任务。另一项后台任务使用ZRANGE…WITHSCORES进行查询，删除过期的条目。
   - 计数：进行各种数据统计的用途是非常广泛的，比如想知道什么时候封锁一个IP地址。INCRBY命令让这些变得很容易，通过原子递增保持计数；GETSET用来重置计数器；过期属性用来确认一个关键字什么时候应该删除。
   - 特定时间内的特定项目：这是特定访问者的问题，可以通过给每次页面浏览使用SADD命令来解决。SADD不会将已经存在的成员添加到一个集合。
   - Pub/Sub：在更新中保持用户对数据的映射是系统中的一个普遍任务。Redis的pub/sub功能使用了SUBSCRIBE、UNSUBSCRIBE和PUBLISH命令，让这个变得更加容易。
   - 队列：在当前的编程中队列随处可见。除了push和pop类型的命令之外，Redis还有阻塞队列的命令，能够让一个程序在执行时被另一个程序添加到队列。

