# #
- 1、多线程有什么用？

  - 1、发挥多核CPU的优势

       随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的"多线程"那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程"同时"运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。

  - 2、防止阻塞
       从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。
   - 3、便于建模

      这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。

- 2、线程和进程的区别是什么？

      进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

- 3、Java实现线程有哪几种方式？

     1、继承Thread类实现多线程
     2、实现Runnable接口方式实现多线程
     3、使用ExecutorService、Callable、Future实现有返回结果的多线程

    参考：http://mp.weixin.qq.com/s/39Sb60J0DC2mNN6DYvpFtg

- 4、启动线程方法start()和run()有什么区别？
 
    只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。

- 5、怎么终止一个线程？如何优雅地终止线程？

   stop终止，不推荐。
   参考：https://mp.weixin.qq.com/s/FPhtbM7Wdyr0iZqbdKecpA

- 6、一个线程的生命周期有哪几种状态？它们之间如何流转的？

   参考：http://mp.weixin.qq.com/s/hD3ie47XEWQQ577tX0Sawg

- 7、线程中的wait()和sleep()方法有什么区别？

    这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器

    参考：http://mp.weixin.qq.com/s/7E8ywAQO8QS7C94LJN2vww

- 8、多线程同步有哪几种方法？

    Synchronized关键字，Lock锁实现，分布式锁等。

- 9、什么是死锁？如何避免死锁？

   死锁就是两个线程相互等待对方释放对象锁。
  参考：http://mp.weixin.qq.com/s/soQG2pxTymgHzzNQqYYNgg

- 10、多线程之间如何进行通信？

   wait/notify

- 11、线程怎样拿到返回结果？
  实现Callable接口。

- 12、violatile关键字的作用？

    一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：

   参考：http://mp.weixin.qq.com/s/TixFzi3JjXy0nQtviuVFOA

   1、多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据

   2、代码底层执行不像我们看到的高级语言----Java程序这么简单，它的执行是Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率

  从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。

- 13、新建T1、T2、T3三个线程，如何保证它们按顺序执行？

   用join方法。参考：
   http://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg

- 14、怎么控制同一时间只有3个线程运行？

    用Semaphore。

- 15、为什么要使用线程池？

    我们知道不用线程池的话，每个线程都要通过new Thread(xxRunnable).start()的方式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的CPU和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存。

- 16、常用的几种线程池并讲讲其中的工作原理。

    参考：http://mp.weixin.qq.com/s/L2KKLlmOKJUQKfLdFa-1FA

- 17、线程池启动线程submit()和execute()方法有什么不同？

    execute没有返回值，如果不需要知道线程的结果就使用execute方法，性能会好很多。
submit返回一个Future对象，如果想知道线程结果就使用submit提交，而且它能在主线程中通过Future的get方法捕获线程中的异常。

- 18、CyclicBarrier和CountDownLatch的区别？

   两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：
   - 1、CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行
   -   2、CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务
  -    3、CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了

   参考：
   http://mp.weixin.qq.com/s/JqTKpkH19at31aadfmVk9w
   http://mp.weixin.qq.com/s/mZ-eht0bDwffdGQ_HXr0Ag

- 19、什么是活锁、饥饿、无锁、死锁？

     参考：http://mp.weixin.qq.com/s/_z4yNYunaunqSDjktKU7EQ

- 20、什么是原子性、可见性、有序性？

     参考：http://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA
 
- 21、什么是守护线程？有什么用？

     参考：http://mp.weixin.qq.com/s/Tb0_mdWN46bAdeRlbBQO1w

- 22、一个线程运行时发生异常会怎样？

     如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。

- 23、线程yield()方法有什么用？

     Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

- 24、什么是重入锁？

     所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。

- 25、Synchronized有哪几种用法？

    锁类、锁方法、锁代码块。

- 26、Fork/Join框架是干什么的？

    大任务自动分散小任务，并发执行，合并小任务结果。
    参考：http://mp.weixin.qq.com/s/YQa2_daDZbJsTxrqv45-QQ

- 27、线程数过多会造成什么异常？

    线程过多会造成栈溢出，也有可能会造成堆异常。

- 28、说说线程安全的和不安全的集合。

    参考：http://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g

- 29、什么是CAS算法？在多线程中有哪些应用。

     CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。

    java.util.concurrent.atomic包下面的Atom****类都有CAS算法的应用。

    参考：http://mp.weixin.qq.com/s/HOAvNG6UcTdpb0mhPSTakg

- 30、怎么检测一个线程是否拥有锁？

     java.lang.Thread#holdsLock方法

- 31、Jdk中排查多线程问题用什么命令？

     jstack

- 32、线程同步需要注意什么？

    1、尽量缩小同步的范围，增加系统吞吐量。
    2、分布式同步锁无意义，要使用分布式锁。
    3、防止死锁，注意加锁顺序。

- 33、线程wait()方法使用有什么前提？

    要在同步块中使用。

- 34、Fork/Join框架使用有哪些要注意的地方？

     如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；
     如果函数的调用栈很深，会导致栈内存溢出；

- 35、线程之间如何传递数据？

     通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的

- 36、保证"可见性"有哪几种方式？

     synchronized和viotatile

- 37、说几个常用的Lock接口实现锁。

     ReentrantLock、ReadWriteLock

- 38、ThreadLocal是什么？有什么应用场景？

     ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。

     用来解决数据库连接、Session管理等。

    参考：http://mp.weixin.qq.com/s/V9w7rZP0138Kg3C9mBFfeg

- 39、ReadWriteLock有什么用？

     ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。

- 40、FutureTask是什么？

     FutureTask表示一个异步运算的任务，FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。

- 41、怎么唤醒一个阻塞的线程？

      如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。

- 42、不可变对象对多线程有什么帮助？

      不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。

- 43、多线程上下文切换是什么意思？

       多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

- 44、Java中用到了什么线程调度算法？

       抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。

- 45、Thread.sleep(0)的作用是什么？

      由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

- 46、Java内存模型是什么，哪些区域是线程共享的，哪些是不共享的？

     参考：http://mp.weixin.qq.com/s/4uXp1n1nlSLuOSPo2Us8mQ

- 47、什么是乐观锁和悲观锁？

      乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

      悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

- 48、Hashtable的size()方法为什么要做同步？

      同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性

     CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句"return count"假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。

- 49、同步方法和同步块，哪种更好？

      同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。

- 50、什么是自旋锁？

      自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。

- 51、Runnable和Thread用哪个好？

      Java不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable会更好。

- 52、Java中notify和notifyAll有什么区别？

      notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。

- 53、为什么wait/notify/notifyAll这些方法不在thread类里面？

      这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你 要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。

- 54、为什么wait和notify方法要在同步块中调用？

       主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。

- 55、为什么你应该在循环中检查等待条件？

       处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。

- 56、Java中堆和栈有什么不同？

      每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。

- 57、你如何在Java中获取线程堆栈？

      对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。

- 58、如何创建线程安全的单例模式？
      参考：http://mp.weixin.qq.com/s/iOvBuv2yFb8Jyw_6WRWpsA

- 59、什么是阻塞式方法？

      阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

- 60、提交任务时线程池队列已满会时发会生什么？

      当线程数小于最大线程池数maximumPoolSize时就会创建新线程来处理，而线程数大于等于最大线程池数maximumPoolSize时就会执行拒绝策略。



