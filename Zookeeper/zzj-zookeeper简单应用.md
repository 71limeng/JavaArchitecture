
# zookeeper简单应用     

## 1.

## 2. 可恢复的zookeeper应用     
关于分布式计算的第一个误区是“网络是可靠的”。按照他们的观点，程序总是有一个可靠的网络，因此当程序运行在真正的网络中时，往往会出现各种备样的故障。让我们看看各种可能的故障模式，以及能够解决故障的措施，使我们的程序在面对故障时能够及时复原      

### 2.1 zookeeper异常       
在Java API中的每一个ZooKeeper操作都在其throws子句中声明了两种类型的异常：
```java
InterruptedException
KeeperException
```

#### InterruptedException异常   
**取消线程操作**            

如果**操作被中断**，则会有一个InterruptedException异常被抛出。          
在Java语言中有一个**取消阻塞方法**的标准机制，即针对**存在阻塞方法的线程调用interrupt()**。一个成功的取消操作将产生一个InterruptedException异常。       

ZooKeeper也遵循这一机制，因此你**可以使用这种方法来取消一个ZooKeeper操作**。使用了ZooKeeper的类或库通常会传播InterruptedException异常，使客户端能够取消它们的操作。**InterruptedException异常并不意味着有故障，而是表明相应的操作已经被取消**，所以在配置服务的示例中，可以通过传播异常来中止应用程序的运行。       

#### KeeperException异常  
(1)如果ZooKeeper服务器发出一个**错误信号**或**与服务器存在通信问题**，抛出的则是KeeperException异常。   
-  针对不同的错误情况，KeeperException异常存在不同的子类。      
例如:　`KeeperException.NoNodeException`是`KeeperException`的一个子类，如果你试图针对一个不存在的znode执行操作，抛出的则是该异常。      
-  每一个KeeperException异常的子类都对应一个关于错误类型信息的代码。
例如:　`KeeperException.NoNodeException`异常的代码是`KeeperException.Code.NONODE`      

(2)有两种方法被用来处理KeeperException异常：
①捕捉KeeperException异常，并且通过检测它的代码来决定采取何种补救措施；      
②另一种是捕捉等价的KeeperException子类，并且在每段捕捉代码中执行相应的操作。        

(3) KeeperException异常分为三大类
- 1.**状态异常**        
当一个**操作因不能被应用于znode树**而导致失败时，就会出现状态异常。状态异常产生的原因通常是在同一时间有另外一个进程正在修改znode。例如，如果一个znode先被另外一个进程更新了，根据版本号执行setData操作的进程就会失败，并收到一个KeeperException.BadVersionException异常，这是因为版本号不匹配。因为对节点的每一个操作都将致使这个节点的版本号增加。         

一些状态异常会指出程序中的错误，例如KeeperException.NoChildrenForEphemeralsException异常，试图在短暂znode下创建子节点时就会抛出该异常。     

- 2.**可恢复异常**          
可恢复的异常是指那些应用程序**能够在同一个ZooKeeper会话中恢复的异常**。一个可恢复的异常是通过`KeeperException.ConnectionLossException`来表示的，它意味着已经丢失了与ZooKeeper的连接。ZooKeeper会尝试重新连接，并且在大多数情况下重新连接会成功，并确保会话是完整的。        

但是ZooKeeper不能判断与`KeeperException.ConnectionLossException`异常**相关的操作是否成功执行**。这种情况就是部分失败的一个例子。这时程序员有责任来解决这种不确定性，并且根据应用的情况来采取适当的操作。在这一点上，就需要对“**幂等**”(idempotent)操作和“**非幂等**”(Nonidempotent)操作进行区分。

**幂等操作**是指那些一次或多次执行都会产生相同结果的操作，例如读请求或无条件执行的setData操作。对于幂等操作，只需要简单地进行重试即可。

**非幂等操作**，就不能盲目地进行重试，因为它们多次执行的结果与一次执行是完全不同的。程序可以通过在znode的路径和它的数据中编码信息来检测是否非幂等操怍的更新已经完成。       

- 3.**不可恢复异常**        
在某些情况下，ZooKeeper会话会失效——也许因为**超时**或因为**会话被关闭**，两种情况下都会收到`KeeperException.SessionExpiredException`异常，或因为身份验证失败，`KeeperException.AuthFailedException`异常。无论上述哪种情况，所有与会话相关联的短暂znode都将丢失，因此应用程序需要在重新连接到ZooKeeper之前重建它的状态。    


## 3. 锁服务        
### 3.1 分布式锁概述        
分布式锁在一组进程之间提供了一种互斥机制。在任何时刻，在任何时刻只有一个进程可以持有锁。分布式锁可以在大型分布式系统中实现领导者选举，在任何时间点，持有锁的那个进程就是系统的领导者。      

>注意：不要将ZooKeeper自己的领导者选举和使用了ZooKeeper基本操作实现的一般领导者选混为一谈。ZooKeeper自己的领导者选举机制是对外不公开的，我们这里所描述的一般领导者选举服务则不同，他是对那些需要与主进程保持一致的分布式系统所设计的。      

#### 强制排序
为了使用ZooKeeper来实现分布式锁服务，我们使用**顺序znode来为那些竞争锁的进程强制排序**。            

思路：      
1. 首先指定一个作为锁的znode, 通常用它来描述被锁定的实体，称为 `/leader`; 
2. 然后希望获得锁的客户端创建一些短暂顺序znode,作为锁znode的子节点；    
3. 在任何时间点，顺序号最小的客户端将持有锁；       
>例如，有两个客户端差不多同时创建znode，分别为`/leader/lock-1`和`/leader/lock-2`，那么创建`/leader/lock-1`的客户端将会持有锁，因为它的znode顺序号最小。ZooKeeper服务是顺序的仲裁者，因为它负责分配顺序号。        
4. 通过删除 znode : `/leader/lock-1` 即可以简单地将锁释放；
5. 另外，如果客户端进程死亡，对应的短暂znode也会删除；  
6. 接下来，创建/leader/lock-2的客户端将持有锁，因为它顺序号紧跟前一个；
7. 通过创建一个关于znode删除的观察，可以使客户端在获得锁时得到通知。

#### 如下申请锁的伪代码     
①在锁znode下创建一个名为lock-的短暂顺序znode，并且记住它的实际路径名(create操作的返回值)。      
②查询锁znode的子节点并且设置一个观察。      
③如果步骤l中所创建的znode在步骤2中所返回的所有子节点中具有最小的顺序号，则获取到锁。退出。      
④等待步骤2中所设观察的通知并且转到步骤2。       

### 3.2 当前问题与方案      
#### 3.2.1 羊群效应     
**问题**            
虽然这个算法是正确的，但还是存在一些问题。第一个问题是这种实现会受到“羊群效应”(herd effect)的影响。考虑有成百上千客户端的情况，**所有的客户端都在尝试获得锁**，每个客户端都会在锁znode上设置一个观察，用于捕捉子节点的变化。每次锁被释放或另外一个进程开始申请获取锁的时候，观察都会被触发并且每个客户端都会收到一个通知。  “**羊群效应**“就是指**大量客户端收到同一事件的通知**，但实际上只有很少一部分需要处理这一事件。在这种情况下，只有一个客户端会成功地获取锁，但是维护过程及向所有客户端发送观察事件会**产生峰值流量**，这会对ZooKeeper服务器造成压力。

**方案解决**            
为了避免出现羊群效应，我们需要**优化通知的条件**。关键在于**只有在前一个顺序号的子节点消失时才需要通知下一个客户端**，而不是删除（或创建）任何子节点时都需要通知。在我们的例子中，如果客户端创建了znode `/leader/lock-1`、`/leader/lock-2`和`/leader/lock-3`，那么只有当`/leader/lock-2`消失时才需要通知`/leader/lock-3`对照的客户端；`/leader/lock-1`消失或有新的znode `/leader/lock-4`加入时，不需要通知该客户端。        


#### 3.2.2 可恢复的异常  
**问题**            

这个申请锁的算法目前还存在另一个问题，就是不能处理因连接丢失而导致的create操作失败。如前所述，在这种情况下，我们不知道操作是成功还是失败。由于创建一个顺序znode是**非幂等操作**，所以我们不能简单地重试，因为如果第一次创建已经成功，重试会使我们多出一个永远删不掉的孤儿zriode(至少到客户端会话结束前）。不幸的结果是将会出现死锁。

**解决方案**        

问题在于，在重新连接之后客户端不能够判断它是否已经创建过子节点。解决方案是在znode的名称中嵌入一个ID，如果客户端出现连接丢失的情况，重新连接之后它便可以对锁节点的所有子节点进行检查，看看是否有子节点的名称中包含其ID。如果有一个子节点的名称包含其ID，它便知道创建操作已经成功，不需要再创建子节点。如果没有子节点的名称中包含其ID，则客户端可以安全地创建一个新的顺序子节点。             
客户端会话的ID是一个长整数，并且在ZooKeeper服务中是**唯一**的，因此非常适合在连接丢失后用于识别客户端。可以通过调用Java ZooKeeper类的getSessionld()方法来获得会话的ID。             

在创建短暂顺序znode时应当采用`lock-<sessionld>-`这样的命名方式，ZooKeeper在其尾部添加顺序号之后，znode的名称会形如`lock-<sessionld>-<sequenceNumber>`。由于顺序号对于父节点来说是唯一的，但对于子节点名并不唯一，因此采用这样的命名方式可以诖子节点在保持创建顺序的同时能够确定自己的创建者。         


#### 3.2.3 不可恢复的异常       
如果一个客户端的ZooKeeper会话过期，那么它所创建的短暂znode将会被删除，已持有的锁会被释放，或是放弃了申请锁的位置。使用锁的应用程序应当意识到它已经不再持有锁，应当清理它的状态，然后通过创建并尝试申请一个新的锁对象来重新启动。注意，这个过程是由应用程序控制的，而不是锁，因为锁是不能预知应用程序需要如何清理自己的状态。        

## 4. ZooKeeper实现共享锁       


